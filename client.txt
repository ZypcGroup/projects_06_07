# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <strings.h>
# include <sys/types.h>
# include <sys/socket.h>
# include <unistd.h>
# include <linux/in.h>
# include<netinet/in.h>
# include<netdb.h>
//# include<fcntl.h>
# include <getopt.h>
# include <sys/stat.h>
# include <fcntl.h>
# include<unistd.h> 
# define PORT 8888       /*侦听端口地址*/
# define COPYMODE 0644
# define  RECUR_TRUE 1
#define oops(msg) {perror(msg);exit(1);}
struct link
{            
        int flag;        //是否递归拷贝文件夹 1 为递归，0 不递归
        int length;     //文件名的长度 
 }; 
struct info{
        int length;     //包长 
        char filename[256];      //DIR_TYPE 的时候，放的是目录名，FILE_TYPE 的时候是文件名
        int filetype;           ///标明其类型 DIR_TYPE 或者是 FILE_TYPE
        char errorinfo[256];     //错误信息  
 };                      
static const struct option long_options[]=
 {
 {
         {"recursive",required_argument,NULL,'r'},
         {"force",required_argument,NULL,'f'},
         {"help",required_argument,NULL,'h'},
         {"version",required_argument,NULL,'v'},
         {NULL,0,NULL,0}
 };

int main(int argc,char *argv[])
{
        int s;                          /*s为socket描述符*/
        char *host,*path,*host_path;
        struct sockaddr_in server_addr; /*服务器地址结构*/
        int err;                        /*返回值*/
        int opt=0;
        int num=2;
        int n_read,out_fd;              /*for message length an out_fd*/
        int options_index = 0;
        char tail[BUFSIZ];
        char yorn[2];
        char buffer[BUFSIZ];
        char dirname[BUFSIZ];
        char file_type[BUFSIZ];
        struct hostent *hp;             /*used to get number*/
        int force;
        int recu;

        //获取操作集合
         while((opt=getopt_long(argc,argv,":r:f:hv", long_options,&options_index))!=EOF )
         { switch(opt) {
                case 'r': recu = RECUR_TRUE; strcnpy(host_path,optarg,strlen(optarg));break;
                case 'f': force = 1;strncpy(host_path,optarg,strlen(optarg));break;
                case 'h': usage();
                case 'v': version();
                case '?': usage();
                default: usage();
                 }
         }
        if (options_index == 1 && argc == 2)
         {
                 if(!str_split(argv[1],host,path,':')) {
                         usage();
                        }
         }
         if (host_path[0] != '\0')
        {
                 if(!str_split(host_path,host,path,':')) {
                         usage();
                         }
        }

        s = socket(AF_INET, SOCK_STREAM, 0);    /*建立一个流式套接字*/
        if(s < 0)               /*出错*/
        {
                printf("socket error\n");
                return -1;
        }

        //设置服务器地址
        bzero(&server_addr, sizeof(server_addr));       /*清零*/
        hp = gethostbyname(argv[1]);                    /*lookup host's ip #'*/
        if(hp == NULL)
                oops(argv[1]);
        bcopy(hp->h_addr,(struct sockaddr *)&server_addr.sin_addr,hp->h_length);
        server_addr.sin_family = AF_INET;               /*协议族*/
//        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);/*本地地址*/
        server_addr.sin_port = htons(PORT);             /*服务器端口*/

        //将用户输入的字符串类型的IP地址转为整型
        inet_pton(AF_INET,argv[1], &server_addr.sin_addr);
        //连接服务器
        if (connect(s, (struct sockaddr*)&server_addr, sizeof(struct sockaddr))!=0)
                oops("connect");
         printf("connect succeed\n");

        //传文件地址，然后读回结果
        printf("argc = %d\n",argc);
        while(argc-num-1 >= 0)
        {
                if(write(s,argv[num],strlen(argv[num])) == -1)
                        oops("write");
                while(1)
                {
                        read(s,dirname,BUFSIZ);
                        read(s,file_type,BUFSIZ);
                        if(strcmp(file_type,"dir") == 0)
                                printf("create a dir");
                        else if(strcmp(file_type,"reg") == 0)
                        {
                                if((out_fd = open(dirname,O_WRONLY))!= -1)
                                {
                                        printf("%s exits,do you want to cover if(y or n) ?",dirname);
                                        scanf("%s",yorn);
                                        if(strcmp(yorn,"n") == 0)
                                        {
                                                close(out_fd);
                                                                                                                           out_fd = create(dirname,COPYMODE);
                                         }
                                 }
                                else
                                        out_fd = create(dirname,COPYMODE);
                                while((n_read = read(s,buffer,BUFSIZ)) > 0)
                                {
                                        printf("%s\n",buffer);
                                        if(write(out_fd,buffer,n_read) == -1)
                                                oops("write");
                                 }
                                close(out_fd);
                         }
                        read(s,tail,BUFSIZ);
                        if(strcmp(tail,"end") == 0)
                        {
                                num++;
                                break;
                         }
                 }
         }




//        process_conn_client(s);                         /*客户端处理过程*/
        close(s);                                       /*关闭连接*/


}
